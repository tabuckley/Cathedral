<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Scrub ↔ Page Sync (Solid Track)</title>
  <link rel="stylesheet" href="main.css" />
  <style>
    html,body{overflow:hidden;margin:0;padding:0;background:#000}

    /* Frame images container */
    #frames-container {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    #frames-container img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: none;
    }
    #frames-container img.active {
      display: block;
    }

    /* overlay should block clicks while visible; when hidden allow events through */
    #screensaver.is-visible{ pointer-events:auto; }
    #screensaver:not(.is-visible){ pointer-events:none; }

    /* === Scrubber container: bottom-center over the model === */
    #scrubber-container {
      position: fixed;
      left: 50%;
      bottom: 14vh;
      transform: translateX(-50%);
      z-index: 10000; /* scrubber stays below overlay */
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      pointer-events: auto;
    }

    /* Keep the overlay above the scrubber (restore old behavior) */
    #screensaver {
      position: fixed;
      inset: 0;
      z-index: 20000; /* overlay covers scrubber until hidden */
      background: #000;
    }
    #screensaver video{
      position:absolute; inset:0; width:100%; height:100%; object-fit:cover;
    }

    /* Screensaver logos - click-through enabled */
    #screensaver img {
      position: absolute;
      pointer-events: none; /* allow clicks to pass through */
      z-index: 1;
      opacity: 1;
      transition: opacity 0.5s ease-out;
    }
    #screensaver.mode-intro img {
      opacity: 0;
    }
    #screensaver .logo-cathedral {
      top: 8vh;
      left: 52%;
      transform: translateX(-50%);
      height: 12vh;
      width: auto;
    }
    #screensaver .logo-heritage {
      top: 4vh;
      right: 2vw;
      height: 20vh;
      width: auto;
    }
    #screensaver .logo-touch {
      bottom: 10vh;
      left: 52%;
      transform: translateX(-50%);
      height: 8vh;
      width: auto;
      animation: touchPulse 3s ease-in-out infinite;
    }
    #screensaver.mode-intro .logo-touch {
      animation: none;
    }
    @keyframes touchPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* Solid neutral slider bar (no gradient) */
    #scrubber {
      width: 54vw;
      -webkit-appearance: none;
      appearance: none;
      outline: none;
      height: 8px;
      background: rgba(255,255,255,0.28);
      border-radius: 999px;
      pointer-events: auto;
      --thumb-color: #F8C84C; /* default = first section (yellow) */
      box-shadow: 0 0 0 1px rgba(0,0,0,0.12) inset, 0 3px 12px rgba(0,0,0,0.08);
    }
    #scrubber::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: color-mix(in oklab, var(--thumb-color) 85%, #ffffff 15%);
      cursor: pointer;
      border: 3px solid rgba(255,255,255,0.9);
      box-shadow: 0 6px 14px rgba(0,0,0,0.18);
    }
    #scrubber::-moz-range-thumb {
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: color-mix(in oklab, var(--thumb-color) 85%, #ffffff 15%);
      cursor: pointer;
      border: 3px solid rgba(255,255,255,0.9);
      box-shadow: 0 6px 14px rgba(0,0,0,0.18);
    }

    /* Empty label container retained for spacing (no numbers) */
    #year-labels {
      order: -1;
      width: 54vw;
      height: 40px;
      margin: 0 0 6px 0;
      opacity: 0;
      transition: opacity 120ms ease-out, transform 120ms ease-out;
    }
    #year-labels.is-visible { opacity: 1; transform: translateY(0); }

    /* Swipe hint icon */
    #swipe-hint {
      position: absolute;
      bottom: 90px;
      left: calc(0.5vw); /* positioned to the left */
      width: 80px;
      height: 80px;
      color: rgba(255, 255, 255, 0.8);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease-out;
    }
    #swipe-hint.is-visible {
      opacity: 1;
      animation: swipeHint 2.5s ease-in-out infinite;
    }
    @keyframes swipeHint {
      0% { transform: translateX(0); opacity: 1; }
      40% { transform: translateX(-25px); opacity: 0.6; }
      50% { opacity: 0.3; }
      60% { transform: translateX(-25px); opacity: 0.6; }
      100% { transform: translateX(0); opacity: 1; }
    }

    @media (max-width: 768px) {
      #scrubber, #year-labels { width: 90vw; }
      #scrubber-container { bottom: 12vh; }
    }
  </style>
</head>
<body>
  <div id="frames-container"></div>

  <div id="scrubber-container">
    <div id="year-labels"></div>
    <input type="range" id="scrubber" aria-label="video scrubber" min="0" max="190" value="0" step="5">
    <img id="swipe-hint" src="swipeicon.png" alt="Swipe to explore" class="is-visible">
  </div>

  <div id="screensaver" class="is-visible" aria-hidden="false">
    <video id="ssv1" playsinline muted preload="auto" autoplay loop>
      <source src="screensaver.mp4" type="video/mp4" />
    </video>
    <video id="ssv2" playsinline muted preload="auto">
      <source src="intro.mp4" type="video/mp4" />
    </video>
    <img src="portsmouth-cathedral.webp" alt="Portsmouth Cathedral" class="logo-cathedral">
    <img src="heritage-fund.png" alt="Heritage Fund" class="logo-heritage">
    <img src="touch.png" alt="Touch to interact" class="logo-touch">
  </div>

  <script>
    const FPS = 24;
    const NUMBER_OF_FRAMES = 190;
    const SEND_INTERVAL_MS = 50;
    const SCREENSAVER_ACCEL = 6.0;
    const BUFFER_FRAMES = 10;

    // Exact shades in the requested order: yellow, yellow, red, green, blue
    const SECTION_COLORS = [
      '#F8C84C', // yellow
      '#F8C84C', // yellow
      '#EC5B46', // red
      '#2E6C56', // green
      '#344696'  // blue
    ];

    const framesContainer = document.getElementById('frames-container');
    const slider = document.getElementById('scrubber');
    const overlay = document.getElementById('screensaver');
    const v1 = document.getElementById('ssv1'); // screensaver loop
    const v2 = document.getElementById('ssv2'); // intro
    const swipeHint = document.getElementById('swipe-hint');

    let lastSentAt = 0;
    let allowSync = false;
    let accelerating = false;
    let frameImages = [];
    let currentFrameIndex = 0;

    // NEW: support resume via ?frame=### from parent
    let startFrame = null;   // integer frame to jump to
    let skipIntro = false;   // when true, don't show overlay

    function sendToParent(obj){
      try { parent.postMessage(JSON.stringify(obj), '*'); }
      catch(_) { try { parent.postMessage(obj, '*'); } catch(_) {} }
    }
    function parseMsg(d){ if (typeof d === 'string') { try { return JSON.parse(d); } catch { return {}; } } return d || {}; }

    const usableStart = BUFFER_FRAMES;
    const usableEnd   = NUMBER_OF_FRAMES - BUFFER_FRAMES;
    const usableSpan  = usableEnd - usableStart;
    const sectionSize = usableSpan / 5;

    function sectionIndexForFrame(frame) {
      if (frame < usableStart || frame >= usableEnd) return -1;
      const idx = Math.floor((frame - usableStart) / sectionSize);
      return Math.min(Math.max(idx, 0), 4);
    }

    function getColorForFrame(frame) {
      const idx = sectionIndexForFrame(frame);
      return idx === -1 ? '#ffffff' : SECTION_COLORS[idx];
    }
    function updateThumbColor(frame) {
      slider.style.setProperty('--thumb-color', getColorForFrame(frame));
    }

    // Preload all frame images
    function preloadFrames() {
      const totalImages = 38; // We have 38 frames (every 5th frame from 0-190)
      for (let i = 1; i <= totalImages; i++) {
        const img = document.createElement('img');
        const paddedNum = String(i).padStart(4, '0');
        img.src = `frames/frame_${paddedNum}.png`;
        img.alt = `Frame ${i}`;
        if (i === 1) img.classList.add('active');
        framesContainer.appendChild(img);
        frameImages.push(img);
      }
    }

    function setBackgroundFrame(frameNum){
      // Convert frame number to image number (every 5th frame)
      const imageIndex = Math.floor(frameNum / 5);
      const clampedIndex = Math.max(0, Math.min(imageIndex, frameImages.length - 1));

      if (clampedIndex !== currentFrameIndex) {
        frameImages[currentFrameIndex].classList.remove('active');
        frameImages[clampedIndex].classList.add('active');
        currentFrameIndex = clampedIndex;
      }
    }

    // Initialize frames
    preloadFrames();

    slider.addEventListener('input', () => {
      const frame = parseInt(slider.value);
      setBackgroundFrame(frame);
      updateThumbColor(frame);

      // Hide swipe hint when slider moves from 0
      if (frame > 0 && swipeHint.classList.contains('is-visible')) {
        swipeHint.classList.remove('is-visible');
      }
      // Show swipe hint when back at 0
      if (frame === 0 && !swipeHint.classList.contains('is-visible')) {
        swipeHint.classList.add('is-visible');
      }

      if (allowSync) {
        const now = performance.now();
        if (now - lastSentAt >= SEND_INTERVAL_MS) {
          lastSentAt = now;
          const ratio = frame / NUMBER_OF_FRAMES;
          sendToParent({ type:'scrubValue', value:ratio });
        }
      }
    });

    // Initialize slider
    slider.max = NUMBER_OF_FRAMES;

    if (skipIntro && startFrame !== null) {
      const clamped = Math.max(0, Math.min(startFrame, NUMBER_OF_FRAMES));
      slider.value = clamped;
      setBackgroundFrame(clamped);
      updateThumbColor(clamped);
      hideOverlay();      // skip screensaver/intro
      allowSync = true;
      if (clamped > 0) swipeHint.classList.remove('is-visible');
      const ratio = clamped / NUMBER_OF_FRAMES;
      sendToParent({ type:'scrubValue', value: ratio });
    } else {
      slider.value = 0;
      setBackgroundFrame(0);
      updateThumbColor(0);
    }


    // Parent → Child messages (now handles initialFrame again)
    addEventListener('message', (evt) => {
      const msg = parseMsg(evt.data);

      // scroll sync
      if (msg.type === 'scrollValue') {
        const ratio = Math.max(0, Math.min(1, Number(msg.value) || 0));
        const frame = Math.floor(ratio * NUMBER_OF_FRAMES);
        slider.value = frame;
        setBackgroundFrame(frame);
        updateThumbColor(frame);
      }

      // initial frame from parent
      if (msg.type === 'initialFrame' && msg.value !== undefined) {
        const raw = parseInt(msg.value);
        const frame = Math.max(0, Math.min(raw, NUMBER_OF_FRAMES - 1));
        startFrame = frame;
        skipIntro = true;

        // Jump immediately
        slider.value = frame;
        setBackgroundFrame(frame);
        updateThumbColor(frame);
        hideOverlay();
        allowSync = true;
        if (frame > 0) swipeHint.classList.remove('is-visible');
        const ratio = frame / NUMBER_OF_FRAMES;
        sendToParent({ type:'scrubValue', value: ratio });
      }
    });

    /* ---------- ORIGINAL OVERLAY FLOW ---------- */
    function showOverlay(){
      overlay.classList.add('is-visible');
      overlay.setAttribute('aria-hidden','false');
      overlay.classList.remove('mode-intro');
      try { v2.pause(); v2.currentTime = 0; } catch(_) {}
      try { v1.pause(); } catch(_) {}
      v1.playbackRate = 1;
      v1.loop = true;
      try { v1.play().catch(()=>{}); } catch(_) {}
      allowSync = false;
      sendToParent({ type: 'lockScroll', value: true });
    }
    function hideOverlay(){
      overlay.classList.remove('is-visible');
      overlay.setAttribute('aria-hidden','true');
      overlay.classList.remove('mode-intro');
      try { v1.pause(); } catch(_) {}
      try { v2.pause(); } catch(_) {}
      allowSync = true;
      sendToParent({ type: 'lockScroll', value: false });
      // Show swipe hint when overlay is dismissed and slider is at 0
      if (parseInt(slider.value) === 0) {
        swipeHint.classList.add('is-visible');
      }
    }
    function accelerateAndFinish(){
      if (!overlay.classList.contains('is-visible')) return;
      if (accelerating) return;
      accelerating = true;
      v1.loop = false;
      v1.playbackRate = SCREENSAVER_ACCEL;
      try { v1.play().catch(()=>{}); } catch(_) {}
    }
    v1.addEventListener('ended', ()=>{
      if (!overlay.classList.contains('is-visible')) return;
      overlay.classList.add('mode-intro');
      try { v2.play().catch(()=>{}); } catch(_) {}
    });
    v2.addEventListener('ended', ()=>{ hideOverlay(); });
    ['pointerdown','click','touchstart','keydown','wheel'].forEach(ev=>{
      overlay.addEventListener(ev, accelerateAndFinish, { passive:true });
    });

    // Boot: if parent sent an initialFrame before metadata, we'll still
    // show the overlay now, but loadedmetadata will immediately skip it.
    showOverlay();
  </script>
</body>
</html>
